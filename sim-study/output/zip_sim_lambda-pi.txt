nohup: ignoring input
Loading required package: StanHeaders
Loading required package: ggplot2
rstan (Version 2.21.5, GitRev: 2e1f913d3ca3)
For execution on a local, multicore CPU with excess RAM we recommend calling
options(mc.cores = parallel::detectCores()).
To avoid recompilation of unchanged Stan programs, we recommend calling
rstan_options(auto_write = TRUE)
── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──
✔ tibble  3.1.8     ✔ dplyr   1.0.9
✔ tidyr   1.2.0     ✔ stringr 1.4.0
✔ purrr   0.3.4     ✔ forcats 0.5.1
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ tidyr::extract() masks rstan::extract()
✖ dplyr::filter()  masks stats::filter()
✖ dplyr::lag()     masks stats::lag()
Loading required package: sp
Loading required package: spData
To access larger datasets in this package, install the spDataLarge
package with: `install.packages('spDataLarge',
repos='https://nowosad.github.io/drat/', type='source')`
Loading required package: sf
Linking to GEOS 3.7.2, GDAL 3.5.1, PROJ 6.3.2; sf_use_s2() is TRUE
Loading required package: Matrix

Attaching package: ‘Matrix’

The following objects are masked from ‘package:tidyr’:

    expand, pack, unpack


Attaching package: ‘spatialreg’

The following objects are masked from ‘package:spdep’:

    get.ClusterOption, get.coresOption, get.mcOption,
    get.VerboseOption, get.ZeroPolicyOption, set.ClusterOption,
    set.coresOption, set.mcOption, set.VerboseOption,
    set.ZeroPolicyOption


Attaching package: ‘extraDistr’

The following object is masked from ‘package:purrr’:

    rdunif

Joining, by = c("time", "region")
Joining, by = "region"
Joining, by = c("time", "region")
Joining, by = "region"
Warning message:
The `x` argument of `as_tibble.matrix()` must have unique column names if `.name_repair` is omitted as of tibble 2.0.0.
Using compatibility `.name_repair`.
This warning is displayed once every 8 hours.
Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated. 

SAMPLING FOR MODEL 'zip_lambda-pi' NOW (CHAIN 1).

SAMPLING FOR MODEL 'zip_lambda-pi' NOW (CHAIN 2).

SAMPLING FOR MODEL 'zip_lambda-pi' NOW (CHAIN 3).
Chain 1: 
Chain 1: Gradient evaluation took 0.074313 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 743.13 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 2: 
Chain 2: Gradient evaluation took 0.08878 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 887.8 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 3: 
Chain 3: Gradient evaluation took 0.078698 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 786.98 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 1: Iteration:   1 / 1000 [  0%]  (Warmup)
Chain 2: Iteration:   1 / 1000 [  0%]  (Warmup)
Chain 3: Iteration:   1 / 1000 [  0%]  (Warmup)
Chain 1: Iteration:  50 / 1000 [  5%]  (Warmup)
Chain 2: Iteration:  50 / 1000 [  5%]  (Warmup)
Chain 3: Iteration:  50 / 1000 [  5%]  (Warmup)
Chain 1: Iteration: 100 / 1000 [ 10%]  (Warmup)
Chain 2: Iteration: 100 / 1000 [ 10%]  (Warmup)
Chain 3: Iteration: 100 / 1000 [ 10%]  (Warmup)
Chain 1: Iteration: 150 / 1000 [ 15%]  (Warmup)
Chain 2: Iteration: 150 / 1000 [ 15%]  (Warmup)
Chain 3: Iteration: 150 / 1000 [ 15%]  (Warmup)
Chain 1: Iteration: 200 / 1000 [ 20%]  (Warmup)
Chain 2: Iteration: 200 / 1000 [ 20%]  (Warmup)
Chain 3: Iteration: 200 / 1000 [ 20%]  (Warmup)
Chain 1: Iteration: 250 / 1000 [ 25%]  (Warmup)
Chain 2: Iteration: 250 / 1000 [ 25%]  (Warmup)
Chain 3: Iteration: 250 / 1000 [ 25%]  (Warmup)
Chain 1: Iteration: 300 / 1000 [ 30%]  (Warmup)
Chain 2: Iteration: 300 / 1000 [ 30%]  (Warmup)
Chain 3: Iteration: 300 / 1000 [ 30%]  (Warmup)
Chain 1: Iteration: 350 / 1000 [ 35%]  (Warmup)
Chain 2: Iteration: 350 / 1000 [ 35%]  (Warmup)
Chain 3: Iteration: 350 / 1000 [ 35%]  (Warmup)
Chain 1: Iteration: 400 / 1000 [ 40%]  (Warmup)
Chain 3: Iteration: 400 / 1000 [ 40%]  (Warmup)
Chain 2: Iteration: 400 / 1000 [ 40%]  (Warmup)
Chain 1: Iteration: 450 / 1000 [ 45%]  (Warmup)
Chain 2: Iteration: 450 / 1000 [ 45%]  (Warmup)
Chain 3: Iteration: 450 / 1000 [ 45%]  (Warmup)
Chain 1: Iteration: 500 / 1000 [ 50%]  (Warmup)
Chain 1: Iteration: 501 / 1000 [ 50%]  (Sampling)
Chain 3: Iteration: 500 / 1000 [ 50%]  (Warmup)
Chain 3: Iteration: 501 / 1000 [ 50%]  (Sampling)
Chain 2: Iteration: 500 / 1000 [ 50%]  (Warmup)
Chain 2: Iteration: 501 / 1000 [ 50%]  (Sampling)
Chain 1: Iteration: 550 / 1000 [ 55%]  (Sampling)
Chain 3: Iteration: 550 / 1000 [ 55%]  (Sampling)
Chain 2: Iteration: 550 / 1000 [ 55%]  (Sampling)
Chain 1: Iteration: 600 / 1000 [ 60%]  (Sampling)
Chain 3: Iteration: 600 / 1000 [ 60%]  (Sampling)
Chain 2: Iteration: 600 / 1000 [ 60%]  (Sampling)
Chain 1: Iteration: 650 / 1000 [ 65%]  (Sampling)
Chain 3: Iteration: 650 / 1000 [ 65%]  (Sampling)
Chain 2: Iteration: 650 / 1000 [ 65%]  (Sampling)
Chain 1: Iteration: 700 / 1000 [ 70%]  (Sampling)
Chain 3: Iteration: 700 / 1000 [ 70%]  (Sampling)
Chain 2: Iteration: 700 / 1000 [ 70%]  (Sampling)
Chain 1: Iteration: 750 / 1000 [ 75%]  (Sampling)
Chain 2: Iteration: 750 / 1000 [ 75%]  (Sampling)
Chain 3: Iteration: 750 / 1000 [ 75%]  (Sampling)
Chain 1: Iteration: 800 / 1000 [ 80%]  (Sampling)
Chain 2: Iteration: 800 / 1000 [ 80%]  (Sampling)
Chain 3: Iteration: 800 / 1000 [ 80%]  (Sampling)
